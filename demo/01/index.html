<!DOCTYPE html>
<html lang="en">
	<head>

		<title>manny (sketchbook demo 0.1)</title>

		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

<!--
		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">

		<script src="/js/watch.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>
-->
		<style>

			body {
				font-family: sans-serif;
				font-size: 13px;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;"
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-terrain {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}
			
			.btn-terrain + .btn-terrain {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/sketchbook_0.2/build/three.min.js"></script>
		<script src="/sketchbook_0.2/build/cannon.min.js"></script>
		<script src="/sketchbook_0.2/build/sketchbook.min.js"></script>
<!--
		<script src="/manny/js/TabUI.js"></script>
		<script src="/manny/js/MeshWalk.js"></script>
		<script src="/manny/js/UVsDebug.js"></script>
		<script src="/manny/js/FBXLoader.js"></script>
		<script src="/manny/js/VirtualInput.js"></script>
		<script src="/manny/js/EditorControls.js"></script>
		<script src="/manny/js/camera-controls.js"></script>
		<script src="/manny/js/SubdivisionModifier.js"></script>
		<script src="/manny/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>
-->
		<script>

			var debugMode = true; // important!
		//	MW.install( THREE ); // important!
		//	CameraControls.install( {THREE:THREE} ); // demo!
		//	THREE.Pathfinding = threePathfinding.Pathfinding;
		//	THREE.PathfindingHelper = threePathfinding.PathfindingHelper;

		//	Number.prototype.format = function (){
		//		return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
		//	};

		</script>

		<script>
/*
		//	TabUI

			(function(){

				var sidePanel = createSidePanel();
				var loginTab = TabUI.add( "Login", "login-tab" );
				var debugTab = TabUI.add( "Debug", "debug-tab" );
				var levelTab = TabUI.add( "Levels", "level-tab" );
				var cameraTab = TabUI.add( "Camera", "camera-tab" );
				var controlTab = TabUI.add( "Controls", "control-tab" );
				var materialTab = TabUI.add( "Material", "material-tab" );
				var animationTab = TabUI.add( "Animations", "animation-tab" );
				var pathfinderTab = TabUI.add( "Pathfinder", "pathfinder-tab" );

				document.body.appendChild( sidePanel );
				TabUI.append("Controls", "Camera", "Material", "Animations", "Levels", "Pathfinder", "Login", "Debug" );
				TabUI.Debug.role.classList.add("active");
				TabUI.Debug.tab.classList.add("in","active");

			})();
*/
		</script>

		<script>

		//	Instantiate loaders.
			const fbxLoader = new Sketchbook.FBXLoader();
			const gltfLoader = new Sketchbook.GLTFLoader();

			world = new Sketchbook.World();

		//	Setup camera.
			world.cameraController.theta = 360;
			world.cameraController.target.z = -3;
			world.cameraController.target.y = 2;

		//	Load world geometry.
			LoadExampleWorld( world );

			player = new Sketchbook.Character({
				position: new THREE.Vector3(1.13, 3, -2.2),
			});

			LoadCharacterModel(player);

			world.add(player);
			player.takeControl();

			function LoadCharacterModel( character ){

				var url = "/sketchbook_0.2/build/models/game_man/game_man.fbx";
				fbxLoader.load( url, function( object ){

					debugMode && console.log( object ); 

				//	Replace materials.
					object.traverse( function( child ){

						if (child.isMesh) {	
							child.castShadow = true;	
							child.receiveShadow = true;	
						}

						if (child.name == 'game_man') {	
							child.material = new THREE.MeshStandardMaterial({	
								envMap: new THREE.TextureLoader().load("https://i.imgur.com/Fx9154f.png"),	
								skinning: true,
							});	
						}	
					});	

					character.setModel(object);	
					character.setModelOffset(new THREE.Vector3(0, -0.1, 0));	
				});	

			}

			function LoadExampleWorld(world) {

			// World.

				var url = "/sketchbook_0.2/build/models/test_world/scene.glb";
				gltfLoader.load( url, function (object)
								{
					world.graphicsWorld.add(object.scene);

					object.scene.traverse(function(obj) {
						if (obj.userData.mass !== undefined) {
							obj.visible = false;
						} else {
							if (obj.userData.visible === 'true') {

								let mapOverride = undefined;
								if (obj.userData.map !== undefined) {
									mapOverride = new THREE.TextureLoader().load('/sketchbook_0.2/build/models/test_world/' + obj.userData.map);
								} else {
									mapOverride = obj.material.map;
								}

								obj.material = new THREE.MeshLambertMaterial({	
									map: mapOverride
								});	
								obj.castShadow = true;
								obj.receiveShadow = true;
								// world.graphicsWorld.add(obj);

							} else if (obj.userData.visible === 'false') {
								obj.visible = false;
							}

							if (obj.userData.physics == 'convex') {

								let mass = obj.userData.mass;
								if(mass === undefined) mass = 0;

								let phys = new Sketchbook.ObjectPhysics.Convex(obj, {
									mass: mass
								});

								let SBobj = new Sketchbook.Object();
								SBobj.setPhysics(phys);

								world.add(SBobj);
							}

							if (obj.userData.physics == 'trimesh') {

								let mass = obj.userData.mass || 0;

								let phys = new Sketchbook.ObjectPhysics.TriMesh(obj, {
									mass: mass
								});

								let SBobj = new Sketchbook.Object();
								SBobj.setPhysics(phys);

								world.add(SBobj);
							}
						}
					});
				});
			}

		</script>

<!--
		<script>

		//	Material Tab.

			(function(){

				var tab = TabUI.Material.tab;

				var row = document.createElement("h3");
				row.textContent = "Material";

				var Signal = signals.Signal;
				materialSelected = new Signal();

				var select = document.createElement("select");
				select.id = "material-droplist";
				select.style.cssText = "width:180px;color:#000;" // float:left;
					+ "border:1px solid;border-radius:4px;padding:2px 4px 4px 4px;"
					+ "font-size:20px;margin-left:10px;";

				row.appendChild( select );
				tab.appendChild( row );

			})();

			(function(){

				var material;
				var textures = {};
				var tab = TabUI.Material.tab;
				var Signal = signals.Signal;
				var textureClicked = new Signal();

				textures.dispose = function(){
					for (var uuid in this ) {
						var texture = this[ uuid ];
						texture.dispose && texture.dispose();
					}
				}

				textureClicked.add( function( uuid ){
					material.roughness = 0;
					material.metalness = 1;
					material.envMap = textures[ uuid ];
					material.envMap.needsUpdate = true;
					material.needsUpdate = true;
				});

				var matcaps = (
				//	"MZV8PzS,L509oY2,Bw7q38p,2FA0yx1,vVDGl7g,3nmnKd4,E36SPOB,MXqauTz,YHsPLdq,soRJv4a," // (large:2K)
					"bixnsMm,MS1GDja,pUytALG,4KwC8wH,Wiqsp9s,gXRFY3U,2tkhy7C,D64zaTR,Id8k2u4,Fx9154f,"
					+ "dqKYFPo,l0Lf1LN,7bH7Ajw,IeAwKEi,VysdwUU,dWAhf12,9ufYr2S,iAWd8i1,mkGDAn5,gf3PsvD,"
					+ "BeHwxKA,GYBQ8Xr,9gxylAS,0p2RT39,aHeUCko,epbmrGs,NKMFDGB,pvXMCj9,QbZ8H2v,aCAVXQb,"
					+ "qU0AEUM,yvwt1wj,D5UeFcC,6GZMeko,rSlm3oM,Xqg7n0A,PzHZLHy,MEzwCJq,wgf7Vl0,GcLQiey,"
					+ "3xH34nj,vhdhgMe,jRTIv3l,xELCxlQ,wtJaViy,Qb0qKtc,7kq8wQ3,F6kcile,0LRxFql,rxUXS8C,"
					+ "qXg0NKn,LSB7hqR,EolEkFt,gOtyiMy,YTE0R32,thsIYPF,ee6stBn,gyYhQao,QOEE3jO,0V4rQPV,"
					+ "l9Tugo0,R86xHzg,IDlk0H9,tUparH7,GISkhjO,JQzRceW,Jl6XqD0,4tyRlwP,aFIJ3Iu,BCqRnS4,"
					+ "1OcGlAa,PqIxyYE,S7J95Cf,QPUvzXD,Stdy1eT,k0nOt5N,rWuDYYe,SGRUmyD,1Ia4Qbk,FFYLtQa,"
					+ "szmc38X,NJSPJlS,8HsVNJA,n3wbE5E,88autaS,7jwTUiI,H1F3Yrv,kgV7aSY,PDFIrWw,Uun8Lpr,"
					+ "Oz16d2L,02gRNwL,bV94g46,eUEtBHC,e1N7JYN,bWpofvm,uzlo3mR,YaXveL2,mw2f1lF,HkWGQb1,"
					+ "N9xoehs,53rWmmo,sBPySdS,1YZKblR,ywKHb7r,3UcbBN7,pWPtSJS,n1a2nB8,lecZa2Q,e3bxY9I,"
					+ "WxVSuFW," // normal matcap.
				).split(",")

				matcaps.pop(); // removes last empty item. (important!)

				var container = document.createElement("div");
				container.id = "matcap-buttons";
				container.style.width = "300px";

				while ( matcaps.length ) {
					(function( id ){

						var button = document.createElement("div");
						button.id = id;
						button.classList.add("btn", "btn-white-outline", "btn-terrain");
						button.style.cssText = "background-size:contain;background-image:url(https://i.imgur.com/"+id+"s.png);";
					//
						var url = "https://i.imgur.com/"+id+".png";   // TODO: cache matcaps.
						var loader = new THREE.ImageLoader();
						loader.setCrossOrigin("anonymous");						// important!
						loader.load( url, function( image ){
							var mapping = THREE.SphericalReflectionMapping;		// important!
							var texture = new THREE.Texture( image, mapping );	// important!
							texture.sourceFile = url;							// important!
							textures[ texture.uuid ] = texture;
							button.setAttribute("uuid", texture.uuid);
							container.appendChild( button );
						});
					//
						button.addEventListener( "click", function(){
							var select = document.getElementById("material-droplist");
							var selected = scene.getObjectByProperty("uuid", select.value);
							if ( !selected ) return;
							var material = selected.material;
							if ( !material ) return;
							var uuid = button.getAttribute("uuid");
							material.roughness = 0;
							material.metalness = 1;
							material.envMap = textures[ uuid ];
							material.envMap.needsUpdate = true;
							material.needsUpdate = true;
							textures.dispose();
						//	textureClicked.dispatch( uuid );
						});

					})( matcaps.shift() );

				}

				tab.appendChild( container );

			})();

		</script>

		<script>

		//	Levels tab.

			(function(){

				var interval, option;
				var terrain, level, texture;
				var material = new THREE.MeshBasicMaterial({
					visible:false, wireframe:false, 
				});

				function textureWatcher(prop, action, value){
					debugMode && console.log(prop, action, value);
					if ( !(level && level.material) ) return;
					texture = level.material.envMap;
				}

				(function(){
					var url = "https://i.imgur.com/yvwt1wj.png";
					var loader = new THREE.ImageLoader();
					loader.setCrossOrigin("anonymous"); // important!
					loader.load( url, function( image ){
						var mapping = THREE.SphericalReflectionMapping; // important!
						texture = new THREE.Texture( image, mapping );	// important!
					});
				})();

				var tab = TabUI.Levels.tab;

				var container = document.createElement("div");
				container.id = "terrain-buttons";
				container.style.cssText = "width:300px;height:600px;margin-bottom:10px;";

				var terrains = [
					"C1W","C2W","C3","C4","C5W","C7W","C8","C9W","C10W",
					"C12W","C13","C14W","C15","C16W","C17W","C18W","C19W",
					"C20W","C21","C22W","C23W","C24W","C25W","C26W","C27W",
					"C28W","C29W","D1","D2","D3","D4","D5","D6","D7","D9",
					"D11","D12","D13","D14","D15","D16","D17","D18","D19",
					"D20","D21","D22","D24","D25",
				];

				while ( terrains.length ) {
					(function( id ){

						var button = document.createElement("div");
						button.id = id;
						button.classList.add("btn", "btn-white-outline", "btn-terrain");
						button.style.cssText = "background-size:contain;background-image:url(/manny/terrain/"+id+".png);";
						button.addEventListener( "click", function clickHandler(){

							clearTimeout( interval );

							interval = setTimeout( function(){
								button.removeEventListener( "click", clickHandler );

								var loader = new THREE.ImageLoader();
								var url = "/manny/terrain/"+button.id+".png";
							//	loader.setCrossOrigin("anonymous");	// important!
								loader.load( url, function( img ){

									if ( !img ) {
										button.addEventListener( "click", clickHandler ); return; // important!
									}

								//  Remove terrain.
									removeTerrain();

								//	Create new terrain.
									setTimeout( function(){

									//	Matrix.
										var minHeight = 5; var maxHeight = 10;
										var matrix = img2matrix( img, img.width, img.height, minHeight, maxHeight );

									//  Geometry.
										var geometry = matrix2geometry( matrix,  img.width-1 , img.height-1 );
										geometry.mergeVertices(); // important!
										geometry.rotateX(-Math.PI/2); 
										geometry.computeBoundingBox();
										geometry.center();
										console.log("geometry:", geometry);

									//  Terrain.
										terrain = new THREE.Mesh(geometry, material);
										terrain.name = "terrain "+button.id; // important!
										terrain.position.set(0, 0, 0);
										var s = 20; terrain.scale.set(s, s, s);
										terrain.geometry.applyMatrix( terrain.matrix );
										console.log("terrain:", terrain);

									//	Add to world (meshwalk.js works with THREE.Geometry only).
										scene.add( terrain ); // optional: cameraControls need it.
										octree.importThreeMesh( terrain );
										cameraControls.rigidObjects.push( terrain );

									//	localPlayer.
										localPlayerController.center.set(0, 50, 0);
										localPlayerController.isIdling = false; // important!

									//	Convert terrain to GLTF.
										var exporter = new THREE.GLTFExporter();
										exporter.parse( terrain, function( object ){
											debugMode && console.log( object );
											var loader = new THREE.GLTFLoader();
											loader.parse( JSON.stringify( object, null, 2 ), "", function ( gltf ) {
												debugMode && console.log( gltf.scene.children[0] );

												var mesh = gltf.scene.children[0];
												mesh.material.visible = true;
												mesh.material.wireframe = true;
												debugMode && console.log( "isGeometry:", mesh.geometry.isGeometry );
												
											//	Level smoother mesh.

												var modifier = new THREE.SubdivisionModifier(1);
												var smoother = modifier.modify( mesh.geometry );
												var material = new THREE.MeshStandardMaterial({
													roughness:0, metalness:1, envMap: texture,
												});

												level = new THREE.Mesh( smoother, material );
												level.name = "level "+button.id; // important!
												level.scale.copy( mesh.scale ); // important!
												level.position.copy( mesh.position ); // important!
												level.material.envMap.needsUpdate = true; // important!
												scene.add( level );

											//	Update texture.
												watch( level.material, "envMap", textureWatcher );

											//	Create material option. 
												setTimeout( function(){
													var select = document.getElementById("material-droplist");
													option = document.createElement("option");
													option.text = level.name;
													option.value = level.uuid;
													select.appendChild( option );
												});

											});
										});


									//	EventListener.
										setTimeout( function(){
											button.addEventListener( "click", clickHandler ); // important!
										});

									});

								}, 

								function( e ){}, // onProgress.
								function(err){
									console.error(err);
									button.addEventListener( "click", clickHandler ); // important!
								});

							}, 1000);


							function img2matrix( image, width, depth, minHeight, maxHeight ) {

								width = width|0;
								depth = depth|0;

								var i, j;
								var matrix = [];
								var canvas = document.createElement( 'canvas' ),
									ctx = canvas.getContext( '2d' );
								var imgData, pixel, channels = 4;
								var heightRange = maxHeight - minHeight;
								var heightData;

								canvas.width  = width;
								canvas.height = depth;

								ctx.drawImage( image, 0, 0, width, depth );
								imgData = ctx.getImageData( 0, 0, width, depth ).data;

								for ( i = 0|0; i < depth; i = ( i + 1 )|0 ) { //row

									matrix.push( [] );

									for ( j = 0|0; j < width; j = ( j + 1 )|0 ) { //col

										pixel = i * depth + j;
										heightData = imgData[ pixel * channels ] / 255 * heightRange + minHeight;

										matrix[ i ].push( heightData );

									}

								}

								return matrix;
							}

							function matrix2geometry ( matrix, width, depth ) {

								var sizeX = matrix[ 0 ].length;
								var sizeZ = matrix.length;

								var halfWidth = width * 0.5;
								var halfDepth = depth * 0.5;
								var geometry = new THREE.PlaneGeometry( width, depth, sizeX - 1, sizeZ - 1 );

								var z90deg = new THREE.Matrix4().makeRotationZ( -Math.PI/2 );
								geometry.applyMatrix( z90deg );

								geometry.vertices.forEach( function ( vertex, i ) {

									var row = ( i / sizeX )|0;
									var col = i % sizeX;

									vertex.x = halfWidth + vertex.x;
									vertex.y = halfDepth + vertex.y;
									vertex.z = matrix[ row ][ col ];

								});

								geometry.computeFaceNormals();
								geometry.computeVertexNormals();

								return geometry;
							}

						});

						container.appendChild( button );

					})( terrains.shift() );
				}

				function removeTerrain(){

					if (level){
						scene.remove(level);
						level.geometry.dispose();
						level.material.dispose();
						unwatch( level.material, "envMap", textureWatcher );
					}

					if (terrain) {
						scene.remove(terrain);
						terrain.geometry.dispose();
						terrain.material.dispose();
						removeRigidObject( terrain );
						octree.removeThreeMesh(terrain.geometry.uuid);
					}

					if ( option ) option.remove();

					setTimeout(function(){
						level = null;
						option = null;
						terrain = null;
					});

					function removeRigidObject( mesh ){
						var rigidObjects = cameraControls.rigidObjects;
						var index = rigidObjects.findIndex( function( item ){
							return item.uuid === mesh.uuid;
						}); if ( index < 0 ) return; // important!
						cameraControls.rigidObjects.splice( index, 1 );
					}

				}

			//	Remove terrain button.

				function RemoveButton(){

					var button = document.createElement("div");
					button.classList.add("btn", "btn-white-outline", "btn-terrain");
					button.style.cssText = "background-size:contain;background:none;";
					button.addEventListener( "click", function(){
						removeTerrain();
						localPlayerController.isIdling = false; // important!
					});
					return button;
				}

				container.appendChild( RemoveButton() );
				tab.appendChild( container );


			//	Export terrain OBJ button.

				(function(){

					var row = document.createElement("div");
					row.style.cssText = "margin:10px 12px;height:35px;text-align:center;";
					row.appendChild( exportOBJButton() );
					tab.appendChild( row );

					function exportOBJButton(){

						var button = document.createElement("div");
						button.id = "export-terrain-obj";
						button.textContent = "Export Terrain as OBJ";
						button.style.cssText = "width:220px;height:40px;font-size:large;";
						button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
						button.addEventListener( "click", function(){
							if ( !terrain ) return;
							var name = terrain.name || "terrain";
							var exporter = new THREE.OBJExporter();
							saveString( exporter.parse( terrain ), name+".obj" );
						});
						return button;
					}

				})();

			//	Export terrain STL button.

				(function(){

					var row = document.createElement("div");
					row.style.cssText = "margin:10px 12px;height:35px;text-align:center;";
					row.appendChild( exportSLTButton() );
					tab.appendChild( row );

					function exportSLTButton(){

						var button = document.createElement("div");
						button.id = "export-terrain-stl";
						button.textContent = "Export Terrain as STL";
						button.style.cssText = "width:220px;height:40px;font-size:large;";
						button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
						button.addEventListener( "click", function(){
							if ( !terrain ) return;
							var name = terrain.name || "terrain";
							var exporter = new THREE.STLExporter();
							saveString( exporter.parse( terrain ), name+".stl" );
						});
						return button;
					}

				})();

			//	Export level GLTF button.

				(function(){

					var row = document.createElement("div");
					row.style.cssText = "margin:10px 12px;height:35px;text-align:center;";
					row.appendChild( exportGFTLButton() );
					tab.appendChild( row );

					function exportGFTLButton(){

						var button = document.createElement("div");
						button.id = "export-level-gltf";
						button.textContent = "Export Level as GLTF";
						button.style.cssText = "width:220px;height:40px;font-size:large;";
						button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
						button.addEventListener( "click", function(){
							if ( !level ) return;
							var name = level.name || "level";
							var exporter = new THREE.GLTFExporter();
							exporter.parse( level, function ( object ) {
								saveString( JSON.stringify( object, null, 2 ), name+".gltf" );
							});
						});
						return button;
					}

				})();

				function saveString( text, filename ) {
					save( new Blob( [ text ], { type: "text/plain" } ), filename );
				}

				function saveArrayBuffer( buffer, filename ) {
					save( new Blob( [ buffer ], { type: "application/octet-stream" } ), filename );
				}

				function save( blob, filename ) {
					var link = document.createElement( "a" );
					link.download = filename;
					link.href = URL.createObjectURL( blob );
					link.addEventListener( "click", function(){
						setTimeout( function(){
							URL.revokeObjectURL( link.href );
						});
					});
					link.click();
				}

			})();


		</script>

		<script>

		//	Animation tab.

			(function(){

				var tab = TabUI.Animations.tab;
				var row = document.createElement("h3");
				row.textContent = "Animation";

			//	var Signal = signals.Signal;
			//	droplistUpdated = new Signal();

				var select = document.createElement("select");
				select.id = "animation-droplist";
				select.style.cssText = "width:180px;color:#000;" // float:left;
					+ "border:1px solid;border-radius:4px;padding:2px 4px 4px 4px;"
					+ "font-size:20px;margin-left:10px;";

				row.appendChild( select );
				tab.appendChild( row );

			})();

			(function(){

			//	Import Animation.

				var tab = TabUI.Animations.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:10px 12px;height:35px;text-align:center;";

				var button1 = IdleButton();
				var button2 = ImportAnimationButton();

				row.appendChild( button1 );
				row.appendChild( button2 );
				tab.appendChild( row );

				function IdleButton(){

					var button = document.createElement("div");
					button.id = "idle-animaton";
					button.textContent = "Pause";
					button.style.cssText = "max-width:120px;width:100px;float:left;height:40px;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function(){
						if ( animationController.currentMotionName == "idling" ) return;
						animationController.play( "idling" ); 
					});

					return button;
				}

				function ImportAnimationButton() {

					var button = document.createElement("div");
					button.id = "import-animaton";
					button.textContent = "Import animation";
					button.style.cssText = "min-width:60%;width:180px;float:right;height:40px;font-size:large;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );

					var input = document.createElement("input");
					input.type = "file";
					input.style.display = "none";
					input.setAttribute("multiple", "");

					var k = 0; // important!
					input.addEventListener( "change", function(){

						for ( var i = 0; i < input.files.length; i++ ) {
							(function( file ){

								var filename = file.name.replace(".fbx", "");
								var extension = file.name.split( "." ).pop().toLowerCase();

								var reader = new FileReader();

								reader.addEventListener( "progress", function ( e ) {
									var size = "(" + Math.floor( e.total / 1000 ).format() + " KB)";
									var progress = Math.floor( ( e.loaded / e.total ) * 100 ) + "%";
									console.log( "Loading", filename, size, progress );
								});

								reader.addEventListener( "load", function ( e ) {

									var data = reader.result;
									var loader = new THREE.FBXLoader();
									var group = loader.parse( data );
									group.name = filename;
									console.log( group );

								//	fbx = group; // debug!

								//	Add animations.
									console.log( group.animations );

									if ( group.animations.length ) {
										var mixer = animationController.mixer;
										var object = animationController.object;
										var animations = group.animations;
										var select = document.getElementById("animation-droplist");
										animations.forEach( function( clip ){
											++k; var name = k+"."+filename;
											animationController.motion[ name ] = mixer.clipAction( clip, object );
											select && select.appendChild( createOption( name ) );
											function createOption(name){
												var option = document.createElement("option");
												option.text = option.value = name;
												return option;
											}
										});
									}

								}, false );
								reader.readAsArrayBuffer( file );

							})( input.files[i] );
						}

					});

					button.addEventListener( "click", function(){
						
						input.value = "";
						input.click();

					});

					button.appendChild( input );
					return button;

				}

			})();

		</script>

		<script>

		//	Debug tab.

			(function(){

				var interval;
				var playerObject;
				var k = 0; // important!
				var tab = TabUI.Debug.tab;

			//	Import Remote Player.

				(function(){
					var row = document.createElement("div");
					var playersButton = importPlayersButton();
					row.style.cssText = "margin:10px 15px;height:35px;text-align:center;";
					row.appendChild( playersButton );
					tab.appendChild( row );
				})();

				(function(){
					var row = document.createElement("div");
					var playersButton = addMorePlayersButton();
					row.style.cssText = "margin:10px 15px;height:35px;text-align:center;";
					row.appendChild( playersButton );
					tab.appendChild( row );
				})();


				function addMorePlayersButton() {

					var button = document.createElement("div");
					button.id = "add-player";
					button.textContent = "Add players";
					button.style.cssText = "min-width:60%;width:fit-content;height:40px;font-size:large;text-overflow:ellipsis;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
					button.addEventListener( "click", function onClickHandler(){

						var url = "/manny/characters/MannyJogging.fbx";
						var loader = new THREE.FBXLoader();
						loader.load( url, function( group ){

							++k; // important!
						//	group is THREE.Group.
							group.name = "MannyJogging";
							var s = 0.00033; group.scale.set(s,s,s); // important!
							debugMode && console.log( group ); 

						//	Replace materials.
							group.children.forEach( function( child ){

								if ( child.type !== "SkinnedMesh" ) return;

								if ( Array.isArray(child.material) ) {
									child.material = child.material.map( function( item ){
										var name = item.name;
										return new THREE.MeshStandardMaterial({
											name:name, skinning:true, // important!
										});
									});

								} else {

									var name = child.material.name;
									child.material = new THREE.MeshStandardMaterial({
										name:name, skinning:true, // important!
									});

								}

								debugMode && console.log( child.material ); 
							});


						//	New player.
							var radius = 10; // player radius.
							var player = new THREE.Object3D();
							player.name = "player_"+k;
							group.position.y = -radius;
							player.add( group );

						//	Random position.
							var r = 25, p = Math.random();
							player.position.set(
								localPlayer.position.x + Math.floor( Math.sin( p * 2*Math.PI ) * r ), // random x,
								radius, // player radius (y),
								localPlayer.position.z + Math.floor( Math.cos( p * 2*Math.PI ) * r ), // random z,
							);

						//	Player helper.
							var playerHelper = new THREE.Mesh(
								new THREE.TetrahedronGeometry(radius, 1),
								new THREE.MeshBasicMaterial({ color:0xffff00, wireframe:true })
							);
							player.add( playerHelper );
							playerHelper.visible = false;
							playerHelper.name = "playerhelper_"+k;

						//	Player controller.
							var playerController = new MW.CharacterController( player, radius );
							playerController.movementSpeed = 40;
							world.add( playerController ); // important!
						//	cameraControls.trackObject = player; // debug!

						//	Player controller random direction.
							playerController.direction = randomDirection();
							player.rotation.y = playerController.direction + Math.PI; // important!
							function randomDirection(){
								return 2 * Math.PI * Math.sin( 2 * Math.PI * Math.random() ); // -3.14 < number > 3.14!
							}

						//	Update rotation.
							(function update(){
								requestAnimationFrame( update );
								player.rotation.y = playerController.direction + Math.PI;
								if ( playerController.center.y < -radius ) {
									playerController.center.set( 0, radius, 0 );
								}
							})();

						//	Animation controller.
							var animationController = new MW.AnimationController( group );
							animationController.play( Object.keys( animationController.motion )[0] );

						//	Update animations.
							var clock = new THREE.Clock();
							(function update(){
								requestAnimationFrame( update );
								var delta = clock.getDelta();
								animationController.update( delta );
							})();

							setTimeout(function(){
								var requestAnimationFrameID;
								crazyIvan( playerController );
								playerController.isRunning = true;
							});

							scene.add( player );
							button.addEventListener( "click", onClickHandler );

						},  function(e){}, function(err){ 
							button.addEventListener( "click", onClickHandler );
						});

						button.removeEventListener( "click", onClickHandler );
					});

					return button;
				}

				function importPlayersButton() {

					var button = document.createElement("div");
					button.id = "import-player";
					button.textContent = "Import players";
					button.style.cssText = "min-width:60%;width:fit-content;height:40px;font-size:large;text-overflow:ellipsis;";
					button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );

					var input = document.createElement("input");
					input.type = "file";
					input.style.display = "none";
					input.setAttribute("multiple", "");

				//	var k = 0; // important!
					input.addEventListener( "change", function(){
						debugMode && console.log( input.files );
						for ( var i = 0; i < input.files.length; i++ ){

							(function( file ){

								var filename = file.name;
								var extension = file.name.split( "." ).pop().toLowerCase();

								var reader = new FileReader();

								reader.addEventListener( "progress", function ( e ) {
									var size = "(" + Math.floor( e.total / 1000 ).format() + " KB)";
									var progress = Math.floor( ( e.loaded / e.total ) * 100 ) + "%";
									console.log( "Loading", filename, size, progress );
								});

								reader.addEventListener( "load", function ( e ) {

									var data = reader.result;
									var loader = new THREE.FBXLoader();
									var group = loader.parse( data );
									group.name = filename;

									++k;
								//	New player.
									var radius = 10; // player radius.
									var player = new THREE.Object3D();
									player.name = "player_"+k;

								//	Random position.
									var r = 100; var p = Math.random();
									player.position.set(
										localPlayer.position.x + Math.floor( Math.sin( p * 2*Math.PI ) * r ), // random x,
										radius,	// player radius (y),
										localPlayer.position.z + Math.floor( Math.cos( p * 2*Math.PI ) * r ), // random z,
									);

								//	Player helper.
									var playerHelper = new THREE.Mesh(
										new THREE.TetrahedronGeometry(10, 1),
										new THREE.MeshBasicMaterial({ 
											color: 0xffff00,  
											wireframe: true,
										})
									);

									playerHelper.name = "playerhelper_"+k;
									if ( group.children.find( function( item ){
										return item.type == "SkinnedMesh";
									}) ) playerHelper.visible = false;

									player.add( playerHelper );

								//	Remote player controller.
									var playerController = new MW.CharacterController( player, radius );
									playerController.movementSpeed = 40;
									world.add( playerController ); // important!
								//	cameraControls.trackObject = player; // debug!


								//	Player controller random direction.
									playerController.direction = randomDirection();
									player.rotation.y = playerController.direction + Math.PI; // important!
									function randomDirection(){
										return Math.PI * Math.sin( 2 * Math.PI * Math.random() ); // -3.14 < number > 3.14!
									}

								//	Update remote player rotation.
									(function update(){
										requestAnimationFrame( update );
										player.rotation.y = playerController.direction + Math.PI;
										if ( playerController.center.y < -radius ) {
											playerController.center.set( 0, radius, 0 );
										}
									})();

								//	fbx is THREE.Group.
									var s = 0.00033; group.scale.set(s,s,s); // important!
									group.position.y = -playerController.radius;
									debugMode && console.log( group ); 

								//	Replace materials.
									group.children.forEach( function( child ){
										if ( child.type !== "SkinnedMesh" ) return;
										if ( Array.isArray(child.material) ) {
											child.material = child.material.map( function( item ){
												var name = item.name;
												return new THREE.MeshStandardMaterial({
													name:name, skinning:true,
												});
											});
										} else {
											var name = child.material.name;
											child.material = new THREE.MeshStandardMaterial({
												name:name, skinning:true,
											});
										}
									});

								//	Add group to scene (before animation controller).
									player.add( group );

								//	Animation controller.
									if ( group.animations.length ) {

										var animationController = new MW.AnimationController( group );
										debugMode && console.log( "animations:", Object.keys( animationController.motion ).join() );
										animationController.play( Object.keys( animationController.motion )[0] );

									//	Update animations.
										var clock = new THREE.Clock();
										(function update(){
											requestAnimationFrame( update );
											var delta = clock.getDelta();
											animationController.update( delta );
										})();
									}

									setTimeout(function(){
										var requestAnimationFrameID;
										crazyIvan( playerController );
										playerController.isRunning = true;
									});
									
									scene.add( player );

								}, false );
								reader.readAsArrayBuffer( file );

							})( input.files[i] );

						}
					});

					button.addEventListener( "click", function(){
						
						input.value = "";
						input.click();

					});

					button.appendChild( input );
					return button;

				}

				function crazyIvan( playerController, requestAnimationFrameID ){

				//	from "The Hunt For Red October" movie.
					var max = Math.PI;
					var limit = THREE.Math.degToRad( 1 );
					var direction = ( playerController.direction + randomDirection() ) % max;
					var deltaAngle = ( direction - playerController.direction );
					//	debugMode && console.log( "crazyIvan to:", direction ); // debug!

					cancelAnimationFrame( requestAnimationFrameID ); // important!

					if ( deltaAngle == 0 || isNaN( deltaAngle ) || isNaN( direction ) ) {
						cancelAnimationFrame( requestAnimationFrameID );
						debugMode && console.log( "something isNaN:", deltaAngle );
						setTimeout( crazyIvan, Math.floor( Math.random() * 10000 ), playerController, requestAnimationFrameID );
						return;
					}

					var clock = new THREE.Clock(); // important!

					(function turn(){

						requestAnimationFrameID = requestAnimationFrame( turn );

						var dt = clock.getDelta();

						if ( direction > 0 && playerController.direction > 0
							&& playerController.direction < direction + limit
							&& playerController.direction > direction - limit 
						   ) {
							playerController.direction = direction % max;
							cancelAnimationFrame( requestAnimationFrameID );
							setTimeout( crazyIvan, Math.floor( Math.random() * 10000 ), playerController, requestAnimationFrameID );
							//	debugMode && console.log( playerController.direction ); // debug!
							return;
						}

						if ( direction < 0 && playerController.direction < 0
							&& playerController.direction > direction - limit
							&& playerController.direction < direction + limit 
						   ) {
							playerController.direction = direction % max;
							cancelAnimationFrame( requestAnimationFrameID );
							setTimeout( crazyIvan, Math.floor( Math.random() * 10000 ), playerController, requestAnimationFrameID );
							//	debugMode && console.log( playerController.direction ); // debug!
							return;
						}

						if ( playerController.direction > 2*max ) {
							//
							debugMode && console.log( "crazyIvan direction:", direction ); // debug!
							debugMode && console.log( "crazyIvan +overflow:", playerController.direction ); // debug!
							debugMode && console.log("");
							//
							playerController.direction = 0;
							cancelAnimationFrame( requestAnimationFrameID );
							setTimeout( crazyIvan, Math.floor( Math.random() * 10000 ), playerController, requestAnimationFrameID );
							return;
						}

						if ( playerController.direction < -2*max ) {
							//
							debugMode && console.log( "crazyIvan direction:", direction ); // debug!
							debugMode && console.log( "crazyIvan -overflow:", playerController.direction ); // debug!
							debugMode && console.log("");
							//
							playerController.direction = 0;
							cancelAnimationFrame( requestAnimationFrameID );
							setTimeout( crazyIvan, Math.floor( Math.random() * 10000 ), playerController, requestAnimationFrameID );
							return;
						}

						if ( deltaAngle > 0 ) playerController.direction += Math.min( limit, dt );
						if ( deltaAngle < 0 ) playerController.direction -= Math.min( limit, dt );

						//	debugMode && console.log( playerController.direction ); // debug!

					})();

					//	setTimeout( crazyIvan, Math.floor( Math.random() * 10000 ), playerController, requestAnimationFrameID );

					function mod( a, n ) { 
						return ( a % n + n ) % n;  // important!
					} 

					function getDeltaAngle( current, target ) {
						var a = mod( ( current - target ), 2 * Math.PI );
						var b = mod( ( target - current ), 2 * Math.PI );
						return a < b ? -a : b;
					}

					function randomDirection(){
						return Math.PI * Math.sin( 2 * Math.PI * Math.random() ); // -3.14 < number > 3.14!
					}

				}

			})();

		</script>

		<script>

			const w = 370; // important!
		//	dispatcher = new THREE.EventDispatcher(); // dispatcher.

		//	Scene.
			scene = new THREE.Scene();

		//	Camera.
			(function(){

				var aspect = (window.innerWidth - w) / window.innerHeight;
				camera = new THREE.PerspectiveCamera( 50, aspect, 1, 10000 );
				camera.position.set(0, 20, 50);

			})();

/*
		//	Moved in renderer.
			window.addEventListener("resize", function onWindowResize() {
				camera.aspect = (window.innerWidth - w) / window.innerHeight;
				camera.updateProjectionMatrix();
			});

		//	Editor Controls.
			(function(){
				controls = new THREE.EditorControls(camera);
				if ( controls && controls instanceof THREE.EditorControls ) {
					camera.lookAt(controls.center); // important!
				}
			})();
*/

		//  Camera Light.
			(function(){

				cameraLight = new THREE.DirectionalLight( 0xdfebff, 0.75 );
				cameraLight.position.set( 0, 500, 300 );
				cameraLight.castShadow = true;
				cameraLight.shadow.mapSize.width  = Math.pow(2, 10); // 2048;
				cameraLight.shadow.mapSize.height = Math.pow(2, 10); // 2048;

				var d = 30;
				cameraLight.shadow.camera.left = - d;
				cameraLight.shadow.camera.right = d;
				cameraLight.shadow.camera.top = d;
				cameraLight.shadow.camera.bottom = - d;
				cameraLight.shadow.camera.far = 10000;

				shadowHelper = new THREE.CameraHelper(cameraLight.shadow.camera);
				shadowHelper.visible = false;

				scene.add( cameraLight, shadowHelper  );

				(function update(){
					requestAnimationFrame( update );
					cameraLight.position.copy( camera.position );
				})();

			})();


		//  Renderer.
			(function(){

				renderer = new THREE.WebGLRenderer({
					antialias: true,
					preserveDrawingBuffer: true,
				});

				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.shadowMap.enabled = true;
				renderer.setClearColor( 0x000000 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( (window.innerWidth - w), window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener("resize", function onWindowResize() {
					renderer.setSize( (window.innerWidth - w), window.innerHeight );
				});

				window.addEventListener("resize", function onWindowResize() {
					camera.aspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
					camera.updateProjectionMatrix();
				});

				mouse = new THREE.Vector2();

				renderer.domElement.addEventListener("mousemove", function(e) {
					mouse.x = ( e.clientX / this.clientWidth ) * 2 - 1;
					mouse.y = - ( e.clientY / this.clientHeight ) * 2 + 1;
				});

				(function render(){
					requestAnimationFrame( render );
					renderer.render( scene, camera );
				})();

			})();


		//	World - Octree.
			(function(){

				world = new MW.World();

				var x = 1500, y = 1500, z = 1500;
				var min = new THREE.Vector3( -x, -y, -z );
				var max = new THREE.Vector3(  x,  y,  z );
				var partition = 7; // nodes: Math.pow( 8, partition )

				octree = new MW.Octree( min, max, partition );
				world.add( octree );

				var clock = new THREE.Clock();

				(function update(){
					requestAnimationFrame( update );
					var delta = clock.getDelta();
					var elapsed = clock.getElapsedTime();
					world.step( Math.min( delta, 0.02 ) );
				})();

			})();

		//	ground.js

			(function(){

				var ground = new THREE.Mesh(
					new THREE.PlaneGeometry( 3000, 3000, 1, 1 ).rotateX(-Math.PI/2),
					new THREE.MeshLambertMaterial({ 
						opacity:1, 
						color:0x829ec4,
					})
				);

			//	We need only the geometry of the ground
			//	so there is not need to add to the scene.
			//	ground.rotation.x = -Math.PI / 2; // THREE.Math.degToRad( -90 );
				octree.importThreeMesh( ground ); // important!
			//	scene.add( ground ); // optional!

			//	Ground Helper.
				groundHelper = new THREE.GridHelper( 3000, 300, 0x444444, 0x444444 );
				scene.add( groundHelper );

			//	Raycaster helper.
				setTimeout(function(){
					var raycaster = new THREE.Raycaster();
					var rayhelper = new THREE.Mesh(
						new THREE.CircleBufferGeometry( 2, 32 ).rotateX(-Math.PI/2),
						new THREE.MeshBasicMaterial( { color:0xffff00, wireframe:false} )
					);
					renderer.domElement.addEventListener("mousemove", function(e) {
						camera.updateMatrixWorld();
						raycaster.setFromCamera( mouse, camera );
						var intersects = raycaster.intersectObject( ground );
						if ( !intersects.length ) return;
						rayhelper.position.copy( intersects[0].point );
					});
					scene.add( rayhelper );
				});

			})();


		//	localPlayer Controller.

			(function(){

				var playerRadius = 10;

			//	local player.
				localPlayer = new THREE.Object3D();
				localPlayer.position.set( 0, 10, 0 );
				localPlayer.name = "localPlayer";
				scene.add( localPlayer );

			//	Player helper.
				localPlayerHelper = new THREE.Mesh(
					new THREE.SphereGeometry( playerRadius, 8, 6 ),
					new THREE.MeshBasicMaterial( { color: 0xff0000,  wireframe: true} )
				);

				localPlayerHelper.name = "playerhelper";
				localPlayer.add( localPlayerHelper );

			//	Player controller.
				localPlayerController = new MW.CharacterController( localPlayer, playerRadius );
				localPlayerController.movementSpeed = 50;
				localPlayerController.maxSlopeGradient = 0.5
				world.add( localPlayerController ); // important!

			//	CameraLight target.
				cameraLight.target = localPlayer;

			//	Update rotation.
				(function update(){
					requestAnimationFrame( update );
					localPlayer.rotation.y = localPlayerController.direction + Math.PI; // important!
				})();

			})();

			(function(){

			//	Camera controls.

				cameraControls = new MW.TPSCameraControl(
					camera, 			// three.js camera.
					localPlayer,		// tracking object.
					{	
						el: renderer.domElement,
						offset: new THREE.Vector3( 0, 0, 0 ), // eye height.
						radius: 34, // default distance of the character to the camera.
						minRadius: 1,
						maxRadius: 280,
						rigidObjects: [],
					}
				);

			//	keyInputControls.

				keyInputControls = new MW.KeyInputControl();

				keyInputControls.addEventListener( "movekeyon", function () { 
					localPlayerController.isRunning = true; 
				});

				keyInputControls.addEventListener( "movekeyoff", function () { 
					localPlayerController.isRunning = false; 
				});

				keyInputControls.addEventListener( "jumpkeypress", function () { 
					localPlayerController.jump(); 
				});

			// synch with keybord input and camera control input.
				keyInputControls.addEventListener( "movekeychange",  function () {
					var cameraFrontAngle = cameraControls.getFrontAngle();
					var characterFrontAngle = keyInputControls.frontAngle;
					localPlayerController.direction = THREE.Math.degToRad( 360 ) - cameraFrontAngle + characterFrontAngle;
				});

/*
			//	"updated" event is fired by "cameraControls.update()"
				cameraControls.addEventListener( "updated", function () {
				//	it updates character front angle with the camera view.
				//  We want camera independed from character front angle,
				//	so we keep it disactivated. Maybe used somewhere later.
					var cameraFrontAngle = cameraControls.getFrontAngle();
					var characterFrontAngle = keyInputControls.frontAngle;
					localPlayerController.direction = THREE.Math.degToRad( 360 ) - cameraFrontAngle + characterFrontAngle;
				});
*/
				(function update(){
					requestAnimationFrame( update );
					cameraControls.update();
				})();

			})();

		//	turnTo.js

			(function(){

				localPlayerController.turnTo    = turnto.bind( localPlayerController );
				localPlayerController.turnBack  = turnto.bind( localPlayerController,  0 );
				localPlayerController.turnFront = turnto.bind( localPlayerController,  Math.PI );
				localPlayerController.turnLeft  = turnto.bind( localPlayerController, -Math.PI/2 );
				localPlayerController.turnRight = turnto.bind( localPlayerController,  Math.PI/2 );

				function turnto( rad, immediate ){

					var requestAnimationFrameID;
					var limit = THREE.Math.degToRad(1);
					var frontAngle = Math.PI - cameraControls.getFrontAngle();
					var deltaAngle = getDeltaAngle( this.direction, frontAngle + rad );

					var turn = () => {

						requestAnimationFrameID = requestAnimationFrame( turn );

						if ( isNaN( deltaAngle ) ) {
							cancelAnimationFrame( requestAnimationFrameID );
							return;
						}

						if ( immediate ) {
							this.direction += deltaAngle;
							cancelAnimationFrame( requestAnimationFrameID );
							return;
						}

						if ( Math.abs( deltaAngle ) < limit ) {
							this.direction += deltaAngle;
							cancelAnimationFrame( requestAnimationFrameID );
							return;
						}

						this.direction = mod( this.direction += ( deltaAngle *= 0.5 ), 2 * Math.PI );

					};

					return turn();

					function mod( a, n ) { 
						return ( a % n + n ) % n;  // important!
					} 

					function getDeltaAngle( current, target ) {
						var a = mod( ( current - target ), 2 * Math.PI );
						var b = mod( ( target - current ), 2 * Math.PI );
						return a < b ? -a : b;
					}

				}

			})();

		//	joystickControls.

			(function(){

				var joystick1, joystick2;

				var joysticControls1 = document.createElement( "div" );
				joysticControls1.id = "joystick-controls-1";
				joysticControls1.classList.add("joystick-controls");
				document.body.appendChild( joysticControls1 );

				var joysticControls2 = document.createElement( "div" );
				joysticControls2.id = "joystick-controls-2";
				joysticControls2.classList.add("joystick-controls");
				document.body.appendChild( joysticControls2 );

				var joystick1Selector  = "#joystick1";
				var joystick2Selector  = "#joystick2";
				var jumpButtonSelector = "#jumpButton";

				var joystickControlsSelector  = ".joystick-controls";
				var joystickControls1Selector = "#joystick-controls-1";
				var joystickControls2Selector = "#joystick-controls-2";

				joystick1  = new virtualInput.Joystick( $( joystickControls1Selector ), 94, { id: "joystick1" } );
				joystick2  = new virtualInput.Joystick( $( joystickControls2Selector ), 94, { id: "joystick2" } );
				jumpButton = new virtualInput.Button(   $( joystickControls1Selector ), 58, { id: "jumpButton", label: "<b>JUMP</b>" } ); // buttonSvgSrc

				joystick1.addEventListener( "active", function onActive() { 

					if (  localPlayerController.isJumping 
						|| !localPlayerController.isGrounded 
						|| localPlayerController.isOnSlope ) {
						return;
					}

					localPlayerController.isRunning = true;

				});

				joystick1.addEventListener( "disactive", function onDisactive() { 

					if (  localPlayerController.isJumping 
						|| !localPlayerController.isGrounded 
						||  localPlayerController.isOnSlope ) {
						return;
					}

					localPlayerController.isRunning = false;

				});

				jumpButton.addEventListener( "press", function onPress() { 

					if (  localPlayerController.isJumping 
						|| !localPlayerController.isGrounded 
						|| localPlayerController.isOnSlope ) {
						return;
					}

					localPlayerController.jump();

				});

				joystick1.update = function(){

					if ( this.isActive ) {

						localPlayerController.direction = (3 * Math.PI/2) - cameraControls.getFrontAngle() + this.angle;

					}
				};

				joystick2.update = function(){

					if ( this.isActive ) {

						cameraControls.setLatLon(
							cameraControls.lat + this.position.y * 0.5, // deg.
							cameraControls.lon - this.position.x        // deg.
						);

					}
				};


				(function update(){
					requestAnimationFrame( update );
					joystick1.update();
					joystick2.update();
				})();
				
			})();

		</script>

		<script>

		//	Avatar loader.

			var Signal = signals.Signal;
			mannyLoaded = new Signal();

			var url = "/manny/characters/MannyCatwalkIdle01.fbx";
			var loader = new THREE.FBXLoader();
			loader.load( url, function( group ){

				fbx = group; // debug!

			//	object is THREE.Group.
				group.name = "MannyTheSkeleton5.1";
				var s = 0.00033; group.scale.set(s,s,s); // important!
			//	group.position.y = -localPlayerController.radius;
				debugMode && console.log( group ); 

			//	Replace materials.
				group.children.forEach( function( child ){

					if ( child.type !== "SkinnedMesh" ) return;

					if ( Array.isArray(child.material) ) {
						child.material = child.material.map( function( item ){
							var name = item.name;
							return new THREE.MeshStandardMaterial({
								name:name, skinning:true, // important!
							});
						});

					} else {

						var name = child.material.name;
						child.material = new THREE.MeshStandardMaterial({
							name:name, skinning:true, // important!
						});

					}

					debugMode && console.log( child.material ); 
				});

				(function(){

				//	Collect skinned meshes.
					var meshes = group.children.filter( function( item ){
						return item.type === "SkinnedMesh";
					}); debugMode && console.log( meshes ); 

				//	Create material option. 
					var select = document.getElementById("material-droplist");
					meshes.forEach( function( mesh ){
						option = document.createElement("option");
						option.text = mesh.name;
						option.value = mesh.uuid;
						select.appendChild( option );
					});

				})();

				(function(){
					var url = "https://i.imgur.com/Fx9154f.png";
					var loader = new THREE.ImageLoader();
					loader.setCrossOrigin("anonymous");						// important!
					loader.load( url, function( image ){
						var mapping = THREE.SphericalReflectionMapping;		// important!
						var texture = new THREE.Texture( image, mapping );	// important!
						var material = group.getObjectByName("MannyTheSkeleton_v51").material;
						material.roughness = 0; material.metalness = 1; material.envMap = texture;
						material.envMap.needsUpdate = true; material.needsUpdate = true;
					});
				})();

			//	Add group to scene before animation controller.
			//	localPlayer.add( group );
				localPlayerHelper.visible = true;
				localPlayerController.direction += Math.PI; // important!

			//	Update group rotation.
				(function update(){
					requestAnimationFrame( update );
					group.rotation.y = localPlayerController.direction + Math.PI; // important!
				})();

			//	Update group position.
				(function update(){
					requestAnimationFrame( update );
					group.position.set( 
						localPlayerController.center.x, 
						localPlayerController.center.y-localPlayerController.radius, // -l0
						localPlayerController.center.z 
					);
				})();

/*
			//	CleanUp animation names.
				var animations = group.animations;
				animations.forEach( function( clip ){
					clip.name = clip.name.replace("Armature|", "").toLowerCase();
				});
				debugMode && console.log( animations ); 
*/

			//	Animation controller.

				(function(){

					var animations = group.animations;
					group.animations[0].name = "idling";

					animationController = new MW.AnimationController( group );
					debugMode && console.log( "animations:", Object.keys( animationController.motion ).join() );

					localPlayerController.addEventListener( "startIdling",  function () { 
						animationController.play( "idling" ); 
					});

				//	Animation droplist.

					(function(){

						var select = document.getElementById("animation-droplist");
						Object.keys( animationController.motion ).forEach( function( name ){
							select.appendChild( createOption( name ) );
						});

						select.addEventListener("change", function(){
							var name = select.value;
							animationController.play( name );
							if ( animationController.motion[name].clampWhenFinished ) {
								animationController.motion[ name ].reset();
							}
						});

						watch( animationController, "currentMotionName", function(prop, action, value){
							select.value = value; // debugMode && console.log( prop, action, value );
						});

					})();

					function createOption(name){
						var option = document.createElement("option");
						option.text = option.value = name;
						return option;
					}

				//	Animation controller update.
					var clock = new THREE.Clock();

					(function update(){
						requestAnimationFrame( update );
						var delta = clock.getDelta();
						animationController.update( delta );
					})();

					debugMode && console.log( animationController ); 
					localPlayerController.dispatchEvent( {type:"startIdling"} );


				//	LOAD ANIMATIONS.


					(function(){
						var loader = new THREE.FBXLoader();
						var url = "/manny/animations/Running.fbx";
						loader.load( url, function( group ){
							console.log( group.animations );

						//	Add animation.
							group.animations[0].name = "running";
							var clip = group.animations[0];
							var mixer = animationController.mixer;
							var object = animationController.object;
							animationController.motion.running = mixer.clipAction( clip, object );

						//	Add option.
							var select = document.getElementById("animation-droplist");
							select && select.appendChild( createOption( clip.name ) );

						//	Bind events.
							localPlayerController.addEventListener( "startWalking",  function () { 
								animationController.play( "running" ); 
								animationController.motion.running.reset(); // important!
							});

						});
					})();

					(function(){
						var loader = new THREE.FBXLoader();
						var url = "/manny/animations/Falling.fbx";
						loader.load( url, function( group ){
							console.log( group.animations );

						//	Add animation.
							group.animations[0].name = "falling";
							var clip = group.animations[0];
							var mixer = animationController.mixer;
							var object = animationController.object;
							animationController.motion.falling = mixer.clipAction( clip, object );

						//	Add option.
							var select = document.getElementById("animation-droplist");
							select && select.appendChild( createOption( clip.name ) );

						//	Bind events.
						//	localPlayerController.addEventListener( "startFalling", function () { 
						//		animationController.play( "falling" ); 
						//	});

						});
					})();

					(function(){
						var loader = new THREE.FBXLoader();
						var url = "/manny/animations/Wobbling.fbx";
						loader.load( url, function( group ){
							console.log( group.animations );

						//	Add animation.
							group.animations[0].name = "wobbling";
							var clip = group.animations[0];
							var mixer = animationController.mixer;
							var object = animationController.object;
							animationController.motion.wobbling = mixer.clipAction( clip, object );

						//	Add option.
							var select = document.getElementById("animation-droplist");
							select && select.appendChild( createOption( clip.name ) );

						//	Bind events.
							localPlayerController.addEventListener( "startSliding", function () { 
								animationController.play( "wobbling" ); 
							});

							localPlayerController.addEventListener( "startFalling", function () { 
								animationController.play( "wobbling" ); 
							});

						});
					})();

					(function(){
						var loader = new THREE.FBXLoader();
						var url = "/manny/animations/RunningJump.fbx";
						loader.load( url, function( group ){
							console.log( group.animations );

						//	Add animation.
							group.animations[0].name = "runningJump";
							var clip = group.animations[0];
							var mixer = animationController.mixer;
							var object = animationController.object;
							animationController.motion.runningJump = mixer.clipAction( clip, object );

						//	Add option.
							var select = document.getElementById("animation-droplist");
							select && select.appendChild( createOption( clip.name ) );

						});
					})();

					(function(){
						var loader = new THREE.FBXLoader();
						var url = "/manny/animations/JumpingUp.fbx";
						loader.load( url, function( group ){
							console.log( group.animations );

						//	Add animation.
							group.animations[0].name = "jumpingUp";
							var clip = group.animations[0];
							var mixer = animationController.mixer;
							var object = animationController.object;
							animationController.motion.jumpingUp = mixer.clipAction( clip, object );
							animationController.motion.jumpingUp.setDuration(0.6); // half++ jump duration in sec.
							animationController.motion.jumpingUp.clampWhenFinished = true;
							animationController.motion.jumpingUp.setLoop( THREE.LoopPingPong );

						//	Add option.
							var select = document.getElementById("animation-droplist");
							select && select.appendChild( createOption( clip.name ) );

						//	Bind events.
							localPlayerController.addEventListener( "startJumping", function() { 
								if ( !localPlayerController.isRunning ) {
									animationController.play( "jumpingUp" ); 
									animationController.motion.jumpingUp.reset(); // important!
								} else {
									animationController.play( "runningJump" );
									animationController.motion.runningJump.reset(); // important!
								}
							});
						});
					})();

				})();

				scene.add( group );

			//	Skeleton helper.

				(function(){
					var armature = group.getObjectByName("Armature");
					skeletonHelper = new THREE.SkeletonHelper(armature);
					scene.add( skeletonHelper );
				})();

			}, 

			function onProgress( e ){
				var size = "(" + Math.floor( e.total / 1000 ).format() + " KB)";
				var progress = Math.floor( ( e.loaded / e.total ) * 100 ) + "%";
				console.log( "Loaded", progress, "of", size,  );
			},

			function onError( err ){
				console.error(err);
			});

		</script>

		<script>

		//	Debug tab.

			(function(){

				var mesh;
				var height = 12;
				var radius = 20;
				var segments = 8;

				var url = "https://i.imgur.com/rxUXS8C.png";
				var loader = new THREE.ImageLoader();
				loader.setCrossOrigin("anonymous"); // important!
				loader.load( url, function( image ){

					var mapping = THREE.SphericalReflectionMapping; // important!
					var texture = new THREE.Texture( image, mapping );	// important!

					var geometry = new THREE.CylinderGeometry(radius/3, radius, height, segments, 1);
					geometry.computeFaceNormals(); // geometry.computeVertexNormals();
				//	geometry.computeBoundingSphere(); geometry.computeBoundingBox();
					var material = new THREE.MeshStandardMaterial({
						roughness:0, metalness:1, envMap:texture,
					});

					mesh = new THREE.Mesh( geometry, material );
					mesh.position.y = ( height * 0.5 ) - 1;
					mesh.material.envMap.needsUpdate = true; // important!

				});

			//	Create Blocks Button.

				var interval;
				var tab = TabUI.Debug.tab;
				var row = document.createElement("div");
				row.style.cssText = "margin:10px 15px;height:35px;text-align:center;";

				var button = document.createElement("div");
				button.id = "create-blocks";
				button.textContent = "Create bases";
				button.style.cssText = "min-width:60%;width:fit-content;height:40px;font-size:large;text-overflow:ellipsis;";
				button.classList.add( "form-control", "btn", "btn-primary", "btn-white-outline", "gradient-btn" );
				button.addEventListener( "click", function(){
					clearTimeout( interval );
					interval = setTimeout( function(){
						for ( var i = 100; i > 0; i-- ){
							var base = mesh.clone();
							base.position.set(
								Math.floor( Math.cos( Math.random() * 2*Math.PI ) * 1000 ),
								mesh.position.y,
								Math.floor( Math.cos( Math.random() * 2*Math.PI ) * 1000 ),
							);
							scene.add( base );
							octree.importThreeMesh( base );
							base.material.envMap.needsUpdate = true; // important!
						}
					}, 250);
				});

				row.appendChild( button );
				tab.appendChild( row );

			})();

		</script>
-->
		<script>
/*
*/
		</script>

	</body>
</html>
